dist(rbind(bd[3,1:nc],centros[,-1]))
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
dist(rbind(bd[4,1:nc],centros[,-1]))
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
dist(rbind(bd[6,1:nc],centros[,-1]))
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
dist(rbind(bd[7,1:nc],centros[,-1]))
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
dist(rbind(bd[7,1:nc],centros[,-1]))
bd[,7]
bd[7,]
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
dist(rbind(bd[7,1:nc],centros[,-1]))
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
dist(rbind(bd[17,1:nc],centros[,-1]))
bd[17,]
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
dist(rbind(bd[17,1:nc],centros[,-1]))
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
dist(rbind(bd[17,1:nc],centros[,-1]))[,1]
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
dist(rbind(bd[17,1:nc],centros[,-1]))
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
dist(rbind(bd[17,1:nc],centros[,-1]))
#3. Repetir el paso 2 hasta que que ya no existan más re asignaciones
}
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
dist(rbind(bd[17,1:nc],centros[,-1]))
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
dist(rbind(bd[17,1:nc],centros[,-1]))[,1]
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
as.matrix(dist(rbind(bd[17,1:nc],centros[,-1])))
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
as.matrix(dist(rbind(bd[17,1:nc],centros[,-1])))[,1]
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
as.matrix(dist(rbind(bd[17,1:nc],centros[,-1])))[-1,1]
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
aux<-as.matrix(dist(rbind(bd[17,1:nc],centros[,-1])))[-1,1]
aux
?which()
aux
which(aux==min(aux))
which(aux==min(aux))
which(aux==min(aux))
rk<-which(aux==min(aux))
rk
rk<-as.numeric(which(aux==min(aux)))
rk
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
aux<-as.matrix(dist(rbind(bd[1,1:nc],centros[,-1])))[-1,1]
rk<-as.numeric(which(aux==min(aux)))
rk
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
aux<-as.matrix(dist(rbind(bd[30,1:nc],centros[,-1])))[-1,1]
rk<-as.numeric(which(aux==min(aux)))
rk
bd[30,]
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
aux<-as.matrix(dist(rbind(bd[30,1:nc],centros[,-1])))[-1,1]
rk<-as.numeric(which(aux==min(aux)))
rk
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
aux<-as.matrix(dist(rbind(bd[30,1:nc],centros[,-1]),method =distancia ))[-1,1]
rk<-as.numeric(which(aux==min(aux)))
rk
rk
bd$k[30]
rk==bd$k[30]
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
i<-30
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
i<-30
aux<-as.matrix(dist(rbind(bd[i,1:nc],centros[,-1]),method =distancia ))[-1,1]
rk<-as.numeric(which(aux==min(aux)))
bd[i,]
rk
bd$k[i]
bd$k[i]<-rk
bd[i,]
#0. Definición del valor de $k$.
k=6;distancia="euclidean";center="media";semilla=12345
#1. Partición de las observaciones en $k$ grupos, obtener el vector de centros de cada grupo (centroides). Se puede trabajar con la media, la mediana o el medoide.
nf<-nrow(bd)
set.seed(12345)
bd<-data.frame(matrix(rnorm(1000),100,10))
bd
#0. Definición del valor de $k$.
k=6;distancia="euclidean";center="media";semilla=12345
#1. Partición de las observaciones en $k$ grupos, obtener el vector de centros de cada grupo (centroides). Se puede trabajar con la media, la mediana o el medoide.
nf<-nrow(bd)
nc<-ncol(bd)
#bd$k<-rep(seq(1:3),ceiling(nf/k))[1:nf]
set.seed(semilla)
bd$k<-c(1:k,sample(1:k,nf-k,replace = T))
if(centro=="media"){
centros<-bd %>% group_by(k) %>% summarise_at(vars(1:nc),mean)
} else if(centro=="mediana"){
centros<-bd %>% group_by(k) %>% summarise_at(vars(1:nc),median)
}
#0. Definición del valor de $k$.
k=6;distancia="euclidean";centro="media";semilla=12345
bd<-data.frame(matrix(rnorm(1000),100,10))
set.seed(12345)
bd<-data.frame(matrix(rnorm(1000),100,10))
#0. Definición del valor de $k$.
k=6;distancia="euclidean";centro="media";semilla=12345
#1. Partición de las observaciones en $k$ grupos, obtener el vector de centros de cada grupo (centroides). Se puede trabajar con la media, la mediana o el medoide.
nf<-nrow(bd)
nc<-ncol(bd)
#bd$k<-rep(seq(1:3),ceiling(nf/k))[1:nf]
set.seed(semilla)
bd$k<-c(1:k,sample(1:k,nf-k,replace = T))
if(centro=="media"){
centros<-bd %>% group_by(k) %>% summarise_at(vars(1:nc),mean)
} else if(centro=="mediana"){
centros<-bd %>% group_by(k) %>% summarise_at(vars(1:nc),median)
}
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
reasig<-1
while(reasig>0){
reasig<-0
for(i in 1:nf){
#i<-30
aux<-as.matrix(dist(rbind(bd[i,1:nc],centros[,-1]),method =distancia     ))[-1,1]
rk<-as.numeric(which(aux==min(aux)))
#re asignación
if(rk!=bd$k[i]){
bd$k[i]<-rk
reasig<-reasig+1
if(centro=="media"){
centros<-bd %>% group_by(k) %>% summarise_at(vars(1:nc),mean)
} else if(centro=="mediana"){
centros<-bd %>% group_by(k) %>% summarise_at(vars(1:nc),median)
}
}
}
}
bd
centros
bd$k
centros
kcenter<-function(bd,k=2,distancia="euclidean",centro="media",semilla=12345){
#0. Definición del valor de $k$.
#k=6;distancia="euclidean";centro="media";semilla=12345
#1. Partición de las observaciones en $k$ grupos, obtener el vector de centros de cada grupo (centroides). Se puede trabajar con la media, la mediana o el medoide.
nf<-nrow(bd)
nc<-ncol(bd)
#bd$k<-rep(seq(1:3),ceiling(nf/k))[1:nf]
set.seed(semilla)
bd$k<-c(1:k,sample(1:k,nf-k,replace = T))
if(centro=="media"){
centros<-bd %>% group_by(k) %>% summarise_at(vars(1:nc),mean)
} else if(centro=="mediana"){
centros<-bd %>% group_by(k) %>% summarise_at(vars(1:nc),median)
}
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
reasig<-1
while(reasig>0){
reasig<-0
for(i in 1:nf){
#i<-30
aux<-as.matrix(dist(rbind(bd[i,1:nc],centros[,-1]),method =distancia     ))[-1,1]
rk<-as.numeric(which(aux==min(aux)))
#re asignación
if(rk!=bd$k[i]){
bd$k[i]<-rk
reasig<-reasig+1
if(centro=="media"){
centros<-bd %>% group_by(k) %>% summarise_at(vars(1:nc),mean)
} else if(centro=="mediana"){
centros<-bd %>% group_by(k) %>% summarise_at(vars(1:nc),median)
}
}
}
}
#3. Repetir el paso 2 hasta que que ya no existan más re asignaciones
return(list(k=bd$k,centros=centros))
}
rm(list=ls())
library(dplyr)
set.seed(12345)
bd<-data.frame(matrix(rnorm(1000),100,10))
kcenter<-function(bd,k=2,distancia="euclidean",centro="media",semilla=12345){
#0. Definición del valor de $k$.
#k=6;distancia="euclidean";centro="media";semilla=12345
#1. Partición de las observaciones en $k$ grupos, obtener el vector de centros de cada grupo (centroides). Se puede trabajar con la media, la mediana o el medoide.
nf<-nrow(bd)
nc<-ncol(bd)
#bd$k<-rep(seq(1:3),ceiling(nf/k))[1:nf]
set.seed(semilla)
bd$k<-c(1:k,sample(1:k,nf-k,replace = T))
if(centro=="media"){
centros<-bd %>% group_by(k) %>% summarise_at(vars(1:nc),mean)
} else if(centro=="mediana"){
centros<-bd %>% group_by(k) %>% summarise_at(vars(1:nc),median)
}
#2. Para cada observación calcular las distancia euclidiana (u otra) a los centroides y reasignar la observación en base a la menor distancia, re calcular los centroides en base a la re asignación de cada observación
reasig<-1
while(reasig>0){
reasig<-0
for(i in 1:nf){
#i<-30
aux<-as.matrix(dist(rbind(bd[i,1:nc],centros[,-1]),method =distancia     ))[-1,1]
rk<-as.numeric(which(aux==min(aux)))
#re asignación
if(rk!=bd$k[i]){
bd$k[i]<-rk
reasig<-reasig+1
if(centro=="media"){
centros<-bd %>% group_by(k) %>% summarise_at(vars(1:nc),mean)
} else if(centro=="mediana"){
centros<-bd %>% group_by(k) %>% summarise_at(vars(1:nc),median)
}
}
}
}
#3. Repetir el paso 2 hasta que que ya no existan más re asignaciones
return(list(k=bd$k,centros=centros))
}
bd<-data.frame(matrix(rnorm(1000),100,10))
bd
set.seed(12345)
bdtest<-data.frame(matrix(rnorm(1000),100,10))
kcenter(bdtest,k=5)
nf
nc
kcenter(bdtest,k=5)
mod1<-kcenter(bdtest,k=5)
mod1<-kcenter(bdtest,k=5)
mod2<-kcenter(bdtest,k=5,centro = "mediana")
mod2
mod3<-kmeans(bdtest,5)
mod3
table(mod1$k)
table(mod2$k)
table(mod3$cluster)
bd
bdtest
head(bdtest)
bdtest$k<-mod1$k
head(bdtest)
bdtest %>% filter(k==1)
(bdtest %>% filter(k==1))
(bdtest %>% filter(k==1))[,1:10]
dist((bdtest %>% filter(k==1))[,1:10])
as.matrix(dist((bdtest %>% filter(k==1))[,1:10]))
as.matrix(dist((bdtest %>% filter(k==1))[,1:10]))
library(cluster)
library(cluster)
bdtest
?silhouette()
bdtest[,1:10]
dist(bdtest[,1:10])
aux<-dist(bdtest[,1:10])
mod1$k
aux<-dist(bdtest[,1:10])
#mod1
silhouette(mod1$k,aux)
aux
#mod2
s2<-silhouette(mod2$k,aux)
s2
#mod1
s1<-silhouette(mod1$k,aux)
#mod2
s2<-silhouette(mod2$k,aux)
#mod1
s3<-silhouette(mod3$cluster,aux)
s1
s2
s3
##############################
mean(s1);mean(s2);mean(s3)
##############################
s1
##############################
s1[,3]
##############################
mean(s1[,3]);mean(s2[,3]);mean(s3[,3])
s2[,3]
s3[,3]
bd
plot(s1)
plot(s2)
plot(s3)
#sobre la base IRIS
data("iris")
aux<-kmeans(iris[,-5],3)
s <- silhouette(aux$cluster, dist(iris[,-5]))
plot(s)
#sobre la base IRIS
data("iris")
aux<-kmeans(iris[,-5],5)
s <- silhouette(aux$cluster, dist(iris[,-5]))
plot(s)
aux<-kmeans(iris[,-5],4)
s <- silhouette(aux$cluster, dist(iris[,-5]))
plot(s)
aux<-kmeans(iris[,-5],2)
s <- silhouette(aux$cluster, dist(iris[,-5]))
plot(s)
aux<-kmeans(iris[,-5],3)
s <- silhouette(aux$cluster, dist(iris[,-5]))
plot(s)
aux<-kmeans(iris[,-5],4)
s <- silhouette(aux$cluster, dist(iris[,-5]))
plot(s)
aux<-kmeans(iris[,-5],5)
s <- silhouette(aux$cluster, dist(iris[,-5]))
plot(s)
aux<-kmeans(iris[,-5],10)
s <- silhouette(aux$cluster, dist(iris[,-5]))
plot(s)
aux<-kmeans(iris[,-5],2)
s <- silhouette(aux$cluster, dist(iris[,-5]))
plot(s)
iris
aux<-kmeans(iris[,-5],3)
s <- silhouette(aux$cluster, dist(iris[,-5]))
plot(s)
aux<-kmeans(iris[,-5],2)
s <- silhouette(aux$cluster, dist(iris[,-5]))
plot(s)
bd
mod1$centros
mod2$centros
mod3$centros
mod3$centers
?pam
mod1$centros
mod4<-pam(bdtest,k=5)
mod4$medoids
mod4$clustering
aux<-dist(bdtest[,1:10])
aux<-dist(bdtest[,1:10])
s4<-silhouette(mod4$clustering,aux)
plot(s4)
plot(s4)
aux2<-pam(iris[,-5],2)
aux2<-pam(iris[,-5],3)
aux2<-pam(iris[,-5],3)
ss <- silhouette(aux2$clustering, dist(iris[,-5]))
plot(s)
aux<-kmeans(iris[,-5],3)
s <- silhouette(aux$cluster, dist(iris[,-5]))
plot(s)
#iris
aux2<-pam(iris[,-5],3)
ss <- silhouette(aux2$clustering, dist(iris[,-5]))
plot(ss)
ss <- silhouette(aux2$clustering, dist(iris[,-5]))
plot(ss)
aux$centers
aux2$medoids
?dist
library(fpc)# Flexible Procedures for Clustering
?pamk
sol <- pamk(iris[,-5], krange=2:10, criterion="asw", usepam=TRUE)
sol
sol <- pamk(iris[,-5], krange=3:10, criterion="asw", usepam=TRUE)
sol
sol <- pamk(iris[,-5], krange=3:10, criterion="asw", usepam=TRUE)
sol <- pamk(iris[,-5], krange=2:10, criterion="asw", usepam=TRUE)
sol
sol <- pamk(iris[,-5], krange=2:10, criterion="asw", usepam=TRUE)
sol$nc
pamk(bdtest,krange=2:10,usepam = T)
library(dplyr)
load("C:\\Users\\ALVARO\\Documents\\GitHub\\EST-384\\data\\oct20.RData")
#filtrar los casos
aux<-c("Número departamento","Departamento" ,"Número municipio","Municipio"   ,"CC","FPV","MTS","UCS","MAS - IPSP","21F","PDC","MNR","PAN-BOL","Votos Válidos","Blancos","Nulos")
names(computo)[1]<-"pais"
names(computo)[12]<-"eleccion"
bd<-computo %>% filter(pais=="Bolivia" & eleccion=="Presidente y Vicepresidente") %>% select(aux)
names(bd)[1:4]<-c("idep","ddep","imun","dmun")
bdmun<-aggregate(bd[,5:16],bd[,1:4],sum)
bdmun<-bdmun[,-14]
bdmun[,5:15]<-prop.table(as.matrix(bdmun[,5:15]),1)
bdmun[,5:15]
head(bdmun[,5:15])
#cluster jerarquico
d<-dist(bdmun[,5:15])
plot(hclust(d),hang=-0.1,label=bdmun$dmun,cex=0.5)
# determinar el mejor k y el mejor enlace
mm<-c("single", "complete", "average") # método
k<-2:20 # cantidad de cluster
d<-dist(bdmun[,5:15]) # matriz de distancia
# matriz de resultados
res<-matrix(NA, nrow = 19,ncol=3)
colnames(res)<-mm
rownames(res)<-k
res
#######################
for(i in k){
for(j in 1:3){
h<-hclust(d,method = mm[j])
c<-cutree(h,i)
s<-silhouette(c,d)
res[i-1,j]<-median(s[,3])
}
}
library(cluster)
library(cluster)
#######################
for(i in k){
for(j in 1:3){
h<-hclust(d,method = mm[j])
c<-cutree(h,i)
s<-silhouette(c,d)
res[i-1,j]<-median(s[,3])
}
}
res
max(res)
max(res)==res
#la mejor opción es k=2 con el método average
h<-hclust(d,method = "average")
c<-cutree(h,2)
plot(h,hang=-0.1,labels=bdmun$dmun,cex=0.4)
rect.hclust(h,k=2)
bdmun$cluster<-c
group_by(bdmun,cluster) %>% summarise(mean(CC),mean(`MAS - IPSP`))
library(ape)
h$labels<-bdmun$dmun
plot(as.phylo(h),type="fan")
plot(as.phylo(h),type="fan")
library(dendextend)
library(circlize)
dend <- as.dendrogram(h)
# modify the dendrogram to have some colors in the branches and labels
dend <- dend %>%
color_branches(k=4) %>%
color_labels
# circlize_dendrogram(dend, )
circlize_dendrogram(dend,dend_track_height = 0.8)
table(is.na(airquality$Ozone))
airquality
R<-(!is.na(airquality))*1
R
cor(R)
chisq.test(table(R[,1],R[,2]))
apply(R,2,mean)
table(R[,1],R[,3])
chisq.test(table(R[,1],R[,3]))
chisq.test(table(R[,1],R[,2]))
m1<-glm(Ozone~Solar.R+Wind,data = R,family = "binomial") # logit
R<-as.data.frame(R)
m1<-glm(Ozone~Solar.R+Wind,data = R,family = "binomial") # logit
summary(m1)
R
summary(m1)
summary(lm(Ozone~Solar.R,data=bd2))
m1<-glm(Ozone~Solar.R+Wind,data = R,family = "binomial") # logit
summary(m1)
R
m1<-glm(Ozone~Solar.R,data = R,family = "binomial") # logit
summary(m1)
R$Ozone
bookdown::clean_book(TRUE)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::clean_book(TRUE)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::clean_book(TRUE)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
load(url("https://github.com/AlvaroLimber/EST-384/raw/master/data/eh19.RData"))
library(dplyr)
a<-c(1:10)
recode(a,`1` = 20L,`2` = 20L,`4` = 30L)
eh19p$sexo<-recode(eh19p$s02a_02,"1.Hombre"="H","2.Mujer"="M")
table(eh19p$sexo)
eh19p<-eh19p %>% mutate(sexo2=recode(s02a_02,"1.Hombre"="M","2.Mujer"="F"))
eh19p %>% select(sexo2) %>% table()
# binarias
unique(eh19p$depto)
# se quiere crear una nueva variable, llamada región:
#    Altiplano: LP, OR, PT
#    Valle: CB, CH, TR
#    Llano: SC, BN, PD
# tarea
?if_else() # trabaja con spark, para crear binarios
?case_when() # múltiple categorías basadas en reglas
v1<-c("La Paz","Oruro","Potosí")
v2<-c("Chuquisaca","Cochabamba","Tarija")
v3<-c("Santa Cruz","Beni","Pando")
eh19p %>% mutate(altiplano = depto %in% v1 ) %>% select(altiplano) %>% table()
eh19p <- eh19p %>% mutate(altiplano = depto %in% v1 , valle = depto %in% v2,llano = depto %in% v3)
names(eh19p)
recode(eh19p$depto,"Altiplano" %in% v1)
recode(eh19p$depto,"Altiplano" %in% v1)
v1<-c("La Paz","Oruro","Potosí")
v1
eh19p$depto
recode(eh19p$depto,"Altiplano" %in% v1)
bookdown::clean_book(TRUE)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::clean_book(TRUE)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::clean_book(TRUE)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::clean_book(TRUE)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::clean_book(TRUE)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
,eval=F
bookdown::clean_book(TRUE)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::clean_book(TRUE)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::clean_book(TRUE)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
bookdown::clean_book(TRUE)
bookdown::render_book("index.Rmd", "bookdown::gitbook")
